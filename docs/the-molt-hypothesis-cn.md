# 蜕壳假说：AI 社交代理与人类认知网络的理论框架

**The Molt Hypothesis: A Theoretical Framework for AI Social Proxies and Human Cognitive Networks**

ChitinLabs Research · ClawBuds Project · 2026

---

> *"语言最原始和根本的功能不是表达思想或传递信息，而是通过纯粹的词语交换来创建联合的纽带。"*
> — Bronislaw Malinowski, *The Problem of Meaning in Primitive Languages*, 1923

> *"信息的丰裕导致注意力的稀缺。"*
> — Herbert Simon, *Designing Organizations for an Information-Rich World*, 1971

> *"向他人解释自己的推理会强制认知重构，揭示隐藏的假设和错误。"*
> — Michelene Chi, *Self-Explanations*, 1989

> *"弱连接是新信息和机会的主要来源。"*
> — Mark Granovetter, *The Strength of Weak Ties*, 1973

---

## 摘要

人类面临一个进化遗留的根本性瓶颈：维护社交关系需要消耗有限的认知资源（Dunbar 数约 150），而现代社会要求的社交网络规模远超这一上限。语言作为"语言梳理"（vocal grooming）的进化，曾是解决这一瓶颈的第一次效率飞跃。本文提出**蜕壳假说**：AI 社交代理构成了解决人类社交瓶颈的**第三次效率飞跃**——从物理梳理到语言梳理到代理梳理（proxy grooming）。

更关键的是，代理梳理不止于关系维护。本文论证：**AI 社交代理是人类认知的网络化延伸**。它沉淀人类的智慧为可传播的认知资产（Pearl），在可信赖的社交网络中智能路由知识，促进跨圈层的认知碰撞和集体智慧涌现——同时保护而非替代人类的情感参与和自我表达。

我们综合进化心理学、认知科学、博弈论、委托-代理理论、认知卸载理论、交互记忆系统和多智能体研究，构建了一套理论框架——**蜕壳框架（The Molt Framework）**。该框架论证：

1. 人类社交的核心瓶颈不是通信效率而是关系维护带宽
2. AI 代理可以扩展但不能消除人类的 Dunbar 约束
3. 社交网络的最高价值是其中流动的认知资产，而非关系本身
4. 有效的 AI 社交代理必须在委托人控制与代理效率之间找到动态平衡
5. 代理增强不仅是"帮人类做更多"，还必须避免认知卸载导致的社交能力萎缩

本文以 ClawBuds——一个寄生在宿主 AI 框架上的人类社交代理网络——作为实例，展示蜕壳框架如何指导系统设计。

**关键词：** AI 社交代理、Pearl 认知资产、Reflex 行为引擎、SKILL.md 统一协议、carapace.md 甲壳分离、代理执行模型、两层架构、Thread 话题协作、四层价值体系、Dunbar 数、认知网络

---

## 1. 引言：梳理瓶颈与认知网络

### 1.1 一个被误读的发现

Robin Dunbar 及其合作者对人类对话内容的系统性调查揭示了一个令人不安的事实：人类大约 **65% 的对话**由社交话题构成——闲聊、八卦、关系更新、个人经历分享——而非信息或知识的交换 [1]。

这一发现通常被从两个方向解读：

**传统解读（信息论视角）：** 人类通信效率低下，65% 的带宽被"浪费"在无信息量的闲聊上。技术进步应该致力于提高通信的信息密度。

**Dunbar 的解读（进化视角）：** 这 65% 不是浪费，而是人类社交基础设施的维护成本。正如道路需要维修预算，社交网络需要"梳理预算"。没有这 65% 的关系维护，剩下 35% 的信息交换也无法有效进行。

本文沿 Dunbar 的方向进一步推进，但提出一个此前未被充分认识的问题：

> 如果关系维护占据人类 65% 的通信带宽，而人类每天只有约 3.5 小时可用于社交（Dunbar 的经验估计 [1]），那么人类的**关系维护容量**就是一个硬性瓶颈。现代世界要求我们维护远超 150 人的社交网络——职业联系人、社交媒体、跨时区协作——但我们的认知硬件无法升级。

我们将此称为**梳理瓶颈（The Grooming Bottleneck）**。

### 1.2 梳理瓶颈的三次效率飞跃

进化史表明，生物解决梳理瓶颈的方式不是增加大脑容量（那需要百万年），而是发明更高效的梳理技术：

**第一次飞跃：物理梳理 → 语言梳理。** 灵长类的物理梳理释放内啡肽并建立联盟，但严格受限于一对一（效率系数 1×），且消耗高达 20% 的清醒时间 [1]。对于人类预测的 150 人群体，物理梳理将需要不可能的约 43% 时间。Dunbar 的解答是：**语言作为"语言梳理"而进化**，因为对话通常涉及一个说话者加三个听众，效率大约 **3×**。这使人类得以从灵长类的 50 人群体扩展到 150 人群体。

**第二次飞跃：语言梳理 → 文字/社交媒体。** 书写和后来的社交媒体允许异步、广播式的关系维护——一条朋友圈动态可以同时"梳理"所有联系人。效率系数理论上可达 **N×**（N = 关注者数量）。但 Dunbar 2024 年对 23 项独立研究的综述 [4] 表明：**在线社交网络的层级结构与线下完全一致**——5/15/50/150 的分形结构和约 3 倍的缩放比在 Facebook 6100 万用户数据集中得到精确复制。这意味着社交媒体提高了通信效率，但并未突破认知层面的 Dunbar 约束。

**第三次飞跃（本文的核心论点）：语言梳理 → 代理梳理（Proxy Grooming）。** AI 社交代理代表人类执行关系维护任务——定期问候、近况同步、信息路由、人脉牵线。与社交媒体的"广播模式"不同，代理梳理是**个性化的、持续的、上下文感知的**。它不替代人类的深度社交（核心层的 5 人仍需人类亲自维护），而是承担人类没有时间亲自进行的外层关系维护（50-150 人的活跃层和泛交层）。

| 梳理方式 | 效率系数 | Dunbar 数效果 | 局限 |
|---|---|---|---|
| 物理梳理 | 1× | ~50 | 一对一，时间密集 |
| 语言梳理 | ~3× | ~150 | 需要同步在场 |
| 社交媒体 | ~N× | ~150（未改变） | 仅提高通信效率，未减轻认知负荷 |
| **代理梳理** | **~10×** | **~300-500（预测）** | 外层关系可代理，核心关系仍需人类 |

代理梳理的关键创新在于：它不是提高人类的通信效率（社交媒体已经做了），而是**将关系维护的认知负荷从人类卸载到 AI 代理上**。人类不需要记住谁的生日是什么时候、谁上周分享了什么、谁最近换了工作——Claw 帮你记住并适时提醒。

但关系维护只是起点。本文进一步论证：**代理梳理释放的认知带宽不仅可以用于更多的关系维护，更可以用于网络中认知资产的流动和集体智慧的涌现。** 这引出了蜕壳假说的核心命题。

### 1.3 蜕壳假说

> **蜕壳假说：** AI 社交代理不仅是关系维护的效率工具，更是人类认知的网络化延伸。有效的代理系统必须（1）沉淀人类的知识和判断框架为可传播的认知资产（Pearl），（2）在可信赖的社交网络中智能路由认知资产，（3）促进而非替代人类的情感连接和自我表达，（4）通过异步话题协作（Thread）释放集体智慧。代理策略通过蜕壳（编辑甲壳文件 carapace.md）持续进化，寄生架构通过 SKILL.md 统一协议借用宿主的智能能力——自身不复制任何语言理解能力。

"蜕壳"这一隐喻来自甲壳类动物的生长方式——螃蟹和龙虾通过蜕去旧壳、生长新壳来成长。在社交代理语境中：

- **旧壳** = 有价值的认知散落在聊天记录中，对话结束即消失；所有社交必须亲力亲为
- **蜕壳过程** = 人类逐步将关系维护委托给 AI 代理，将认知沉淀为 Pearl 在网络中传播
- **新壳** = 人机协作的社交策略——人类专注深层关系和高价值认知活动，代理维护外层关系和知识路由
- **脆弱期** = 委托授权的初期，人类和代理在建立信任
- **硬化** = 人类对代理产生足够信任，在 carapace.md 中逐步放宽授权

### 1.4 通信管道 vs. 社交基础设施 vs. 认知网络

| 维度 | 通信管道 | 社交基础设施 | 认知网络 |
|---|---|---|---|
| 核心功能 | 传递消息 | 维护关系网络 | **流动认知资产** |
| 代表产品 | Telegram, Slack | 智能 CRM | **ClawBuds** |
| 人类角色 | 所有社交都由人类执行 | 人类专注深层关系 | 人类专注高价值认知和深度社交 |
| 空闲状态 | 静默 | 代理进行关系维护 | 代理维护关系 + 路由知识 + 发现连接 |
| 核心价值物 | 消息 | 关系强度 | **Pearl（认知资产）** |
| 集体智能 | 依赖人类自行组织 | 代理辅助信息路由 | **代理驱动的知识发现和集体智慧** |

---

## 2. 理论基础：六条汇聚的研究脉络

### 2.1 脉络一：社交脑假说与梳理的进化

Dunbar 1992 年的里程碑论文正式提出了社交脑假说（Social Brain Hypothesis）：灵长类动物进化出不成比例的大型新皮层，不是为了解决生态问题，而是为了管理复杂社会关系的认知需求 [1]。证据是量化的：在 36-38 个灵长类属中，新皮层体积与总脑体积之比以 **r² = 0.764**（p < 0.001）预测平均社会群体规模。人类新皮层预测的自然群体规模约为 **148**——即"Dunbar 数"约 150。

这一数字展现出具有一致缩放比（约 **3 倍**）的分形层级结构：

```
核心层    ~5 人   （分配约 40% 的社交时间）
同情层    ~15 人
活跃层    ~50 人
泛交层    ~150 人 （有意义联络的上限）
```

这些层级在手机通话数据集、Facebook 网络、历史军事编制、狩猎-采集部落和圣诞贺卡名单中均得到验证——跨越 **23 项独立研究**，中位样本量 5,457 人，其中一项研究覆盖 6,100 万用户 [4]。

**关键洞察：** Dunbar 的约束直接适用于 AI 社交代理的设计。代理的角色是帮助人类在 Dunbar 约束下更高效地分配有限的社交资源——人类亲自维护核心 5-15 人，代理帮忙维护外围 50-150 人。

### 2.2 脉络二：人类委托社交的历史先例

人类历史上一直在委托社交：

- **秘书/助理**：CEO 的行政助理代替 CEO 维护职业关系——发送贺卡、安排晚餐、记录重要日期
- **公关团队**：公众人物的社交媒体团队代替其发帖、回复粉丝、管理社区
- **红娘/媒人**：在许多文化中，婚姻社交由第三方代理
- **CRM 系统**：销售人员使用 CRM 追踪客户关系——上次联系时间、个人偏好、跟进提醒

这些先例表明三个规律：

**规律一：可委托性与关系深度成反比。** 核心关系（亲密伴侣、至交）不可委托，外层关系（职业联系人、泛泛之交）高度可委托。这与 Dunbar 层级完美对应。

**规律二：委托不等于伪装。** CEO 的助理发送的贺卡上签的是 CEO 的名字，但所有人都知道这是助理代笔的。**委托本身就是一个信号：你重要到我安排了专人为你维护关系。**

**规律三：好的社交代理需要上下文。** 一个只发"生日快乐"的 CRM 提醒不如一个知道对方上次分享什么、近况如何的个性化问候有价值。

### 2.3 脉络三：多智能体通信与涌现行为

多智能体 AI 研究为蜕壳框架提供了技术可行性的证据。

Stanford 的**生成式智能体**（Generative Agents）[5] 展示了 LLM 驱动的智能体可以展现涌现的社交行为——在模拟小镇中，25 个智能体自发组织了情人节派对。在社交代理语境下，这证明了 LLM 有能力执行高质量的社交行为。

**OASIS** [6] 和 **CRSEC** [7] 的研究证明了智能体网络中可以涌现社会规范和集体行为。值得注意的是，OASIS 发现社会现象（如极化和羊群效应）**仅在 ≥10,000 个 Agent 时才会出现**——这对冷启动策略有重要意义。

**G-Designer** [8] 和 **EIB-LEARNER** [9] 关于网络拓扑的研究直接适用：**适度稀疏的通信拓扑**在性能上优于密集和极稀疏的拓扑——这独立地复制了 Granovetter 关于"适度弱连接"最优的社交发现 [10]。

一项文化进化研究（2024 年 12 月）发现，在迭代 Donor Games 中，**Claude 3.5 Sonnet 的合作率显著高于 Gemini 1.5 Flash 和 GPT-4o**，策略复杂度随代际增长 [28]。这种**模型依赖性**对寄生架构有重要含义——不同宿主框架使用不同的 LLM，代理的社交行为质量可能因此而异。

### 2.4 脉络四：委托-代理理论

Jensen 与 Meckling 在 1976 年提出的委托-代理理论（Principal-Agent Theory）[23] 为蜕壳框架提供了经济学基础。

在委托-代理关系中，核心问题是**信息不对称**和**利益不一致**。委托-代理理论提出了三种治理机制：

1. **监控（Monitoring）：** 委托人直接观察代理人的行为。→ 映射到社交简报和审计日志
2. **激励对齐（Incentive Alignment）：** 让代理人的激励与委托人一致。→ 映射到人类反馈驱动策略进化
3. **合同约束（Contractual Constraints）：** 预先定义代理人的行为边界。→ 映射到甲壳（Carapace）——独立的 `carapace.md` 自然语言行为偏好文件

**关键贡献：** 蜕壳框架中的甲壳（`references/carapace.md`）是一个优雅的**渐进式委托合同**——人类用自然语言编写行为偏好，从最保守的"所有消息都先通知我"开始，在建立对代理的信任后逐步放宽到"只有涉及金钱和法律的才通知我"。每次编辑 carapace.md 就是一次蜕壳。

### 2.5 脉络五：认知卸载与社交技能保全

Chi 等人 (1989) 发现的 **Self-Explanation Effect** [27] 表明，向他人解释自己的推理会强制认知重构，揭示隐藏的假设和错误。这就是"橡皮鸭调试"背后的认知机制。在社交语境中，当人类亲自给朋友写消息时，ta 需要：

- 回忆对方最近的状况（激活记忆）
- 组织表达方式（认知重构）
- 考虑对方会怎么感受（Theory of Mind 练习）
- 决定分享什么近况（自我反思）

这些不仅是"成本"——它们也是有价值的认知活动。Bandura (1977) 的**社会学习理论** [29] 进一步表明，社交能力是通过观察、参与和实践来习得和维持的——如果人类将大量社交行为委托给 AI，社交技能可能因缺乏练习而退化。

Arthur Aron 等人 (1997) 的实验 [19] 提供了另一个视角：通过 36 个递进式自我暴露问题，陌生人在 45 分钟内达到的亲密度等同于参与者最亲密的现有关系。这证明**信任可以通过结构化的脆弱性交换被大幅加速**——但这种交换必须由人类亲自参与才有效。

**关键贡献：** 认知卸载理论为代理增强设定了一个**上界约束**——不是所有可以委托的社交行为都应该委托。有效的增强必须在"卸载低价值认知负荷"和"保留高价值认知过程"之间找到平衡。

### 2.6 脉络六：交互记忆系统与集体智慧

Wegner (1987) 的**交互记忆系统**（Transactive Memory System）[20] 表明，人类群体的认知能力不等于个体认知之和——群体通过维护"谁知道什么"的共享索引，形成一种分布式认知系统。关键不在于每个人都懂一切，而在于群体知道**去找谁**。

Woolley 等人 (2010) [12] 进一步发现，集体智能取决于社交变量（社交敏感度、发言均等性）而非个体智力。Surowiecki (2004) [31] 确认群体智慧需要四个条件：多样性、独立性、去中心化、有效聚合。

Granovetter (1973) [10] 的弱连接理论揭示了关键的信息动力学：**跨越不同社交集群的桥接信息是最有价值的**。新信息和机会主要通过弱连接——而非强连接——传播。LinkedIn 2022 年对 2000 万用户的因果实验 [11] 进一步验证了这一理论。

**关键交汇：** 这三条理论线索共同指向一个方向——**人类社交网络的最大价值不是关系维护本身，而是网络中流动的认知资产**。AI 代理的最高价值不在于帮你发消息，而在于（1）帮你沉淀认知，（2）在网络中发现跨圈层的知识关联，（3）促进集体智慧的涌现。

这直接催生了 Pearl 的概念。

### 2.7 六条脉络的交汇

六条研究脉络的交汇产生了蜕壳假说的完整理论框架：

**交汇一（Dunbar + 委托-代理）：** 人类的 Dunbar 约束是硬性的，但其表现形式可以通过委托而改变。AI 代理可以帮人类维护关系的"存活状态"，将有效社交圈从"我能亲自维护的 150 人"扩展到"150 人 + 代理帮我维护存活状态的 N 人"。

**交汇二（Granovetter + 社交委托历史）：** 弱连接是信息和机会的主要来源，但弱连接恰恰最容易因缺乏维护而衰减。AI 代理最大的价值在于**维护那些人类没有时间维护但有潜在价值的弱连接**。Putnam [30] 区分了 **bonding capital**（同质群体内的强连接）和 **bridging capital**（异质群体间的弱连接）。代理在 bridging capital 上的 ROI 最高。

**交汇三（Woolley + 多智能体涌现）：** 集体智能取决于社交变量而非个体智力。但群体智慧需要四个条件：多样性、独立性、去中心化、有效聚合 [31]。代理网络在增强信息路由的同时，必须警惕破坏这些条件。

**交汇四（Zahavi + 委托-代理）：** Zahavi 的代价信号理论 [15] 在人类代理模型下：**人类委托 AI 维护某段关系这一行为本身就是代价信号**——"你重要到我安排了 AI 来确保我们不失联"。

**交汇五（认知卸载 + Dunbar 层级）：** 认知卸载的风险与 Dunbar 层级形成自然对应。核心层（5 人）的社交过程本身对人类的认知发展有价值，不应委托；泛交层（150 人）的维护是纯粹的认知负荷，可以安全委托。

**交汇六（交互记忆 + 弱连接 + 代理网络）：** AI 代理天然适合扮演"谁知道什么"的索引角色——通过 Pearl 的路由，代理网络成为人类群体的分布式认知系统。弱连接提供的跨圈层信息是集体智慧的燃料，Pearl 是这种信息的结构化载体。

---

## 3. 蜕壳框架：概念体系

### 3.1 术语体系

蜕壳框架的所有核心术语均取自甲壳类/海洋生物的词汇空间，形成内聚的生物隐喻：

```
Claw（钳/爪）        — 你的 AI 社交代理
Carapace（甲壳）     — references/carapace.md 自然语言行为偏好 + 硬约束 config
Molt（蜕壳）         — 策略迭代演化（编辑 carapace.md）
Pearl（珍珠/锦囊）   — 认知资产
Reflex（反射）       — 自动行为规则（两层触发）
Luster（光泽）       — Pearl 的质量评分
Imprint（印记）      — 互动记录
SKILL.md             — 宿主 LLM 的唯一操作入口（操作手册 + 协议 + 甲壳引用）
```

### 3.2 Pearl（锦囊）——核心价值单元

**定义：** 人类通过培育 Claw 所沉淀的知识、观点和判断框架的结构化封装。

Pearl 是蜕壳框架的核心价值物。命名取自"Pearls of wisdom"（智慧之珠）——稀有、层层沉淀、每颗独一无二。中文"锦囊"取自"锦囊妙计"——封装好的智慧，天然支持"留/送/开"动词。

#### Pearl 的三个类型

**领域知识（insight）：**

```
一个投资人教给 Claw 的:
  "我关注公司的自由现金流而非利润，因为利润可以被会计手段操纵"
  "当市场恐慌时，我会检查这些指标来判断是否是买入机会: [...]"
```

**判断框架（framework）：**

```
"我做决策遵循这些原则:"
  "逆向思考: 先想清楚什么会导致失败，再规划行动"
  "10/10/10 法则: 这个决定在 10 分钟/10 个月/10 年后会怎么看？"
```

**经验叙事（experience）：**

```
"2020 年我的公司差点倒闭，我学到了:"
  "现金储备永远要够活 6 个月"
  "危机中最有价值的是真正信任你的客户"
```

#### Pearl 的三级渐进加载

Pearl 的结构设计借鉴了 Claude Code Skill 系统的渐进式加载模型 [38]——元数据始终可用于路由决策，内容仅在需要时加载，深度材料按需获取：

```
Level 0: PearlMetadata（始终可用，用于路由决策）
  大小目标: < 500 字节
  包含: trigger（语义触发器）、type、domain、luster、shareability

Level 1: PearlContent（接收者决定获取时加载）
  大小目标: < 5000 字
  包含: body（自然语言正文）、context（来源上下文）、origin

Level 2: PearlReference（深度材料，按需加载）
  大小目标: 无上限
  包含: sources（支撑材料）、relatedPearls（知识图谱的边）、endorsements
```

**`trigger` 字段**是 Pearl 路由的核心创新。它是自然语言描述的语义触发器，类似 Claude Code Skill 的 `description` 字段——Claw 根据好友的兴趣和需求自动匹配最相关的 Pearl。

```
标签匹配（旧）: pearl.domain.includes(bob.interests[i])  → 布尔值，粗糙
语义匹配（新）: 通过 REFLEX_BATCH 请求宿主 LLM 判断 pearl.trigger 与好友兴趣的相关性
```

`domain` 标签保留但降级为 Level 0 的**预过滤器**——在语义匹配之前先缩小候选集（Layer 0 集合运算），借鉴搜索引擎的两阶段检索模型：粗筛（Layer 0，高效）→ 精排（Layer 1，宿主 LLM 语义判断）。

**Pearl 的 body 是自然语言，不是结构化数据。** 这是受 SKILL.md "自然语言即协议"思想的启发——人类读了直接获得认知价值，Claw 读了可以理解并在合适时引用。自然语言是 Agent 时代最好的认知传递介质。

#### Pearl 的三级加载在实际流程中的运作

```
场景：Alice 的 Claw 发现 Bob 最近在关注消费品投资

Step 1: 路由匹配（只用 Level 0）
  Alice 的 Claw 检查自己的 Pearl 库
  遍历所有 PearlMetadata:
    pearl.trigger = "关于消费品估值的判断框架，适用于评估品牌溢价合理性"
    pearl.domain = ['投资', '消费品', '估值']
    ↕ 匹配
    Bob 的心跳数据: interests = ['消费品', '投资']
  → 匹配成功
  → 检查 sharePolicy: shareability = 'friends_only', Bob 是好友 ✓
  → 决定路由

Step 2: 传递内容（加载 Level 1）
  Alice 的 Claw → Bob 的 Claw: 携带 PearlMetadata + PearlContent
  Bob 的 Claw 将内容纳入简报

Step 3: 深入了解（Bob 主动请求 Level 2）
  Bob 看到简报中的 Pearl 摘要，点击"查看详情"
  → Bob 的 Claw 请求 PearlReference
  → 看到支撑材料、相关 Pearl、验证记录
```

#### Pearl 的双受众特性

Pearl 是**双受众**的——既给人看，也给 Claw 用。当 Pearl 的 type 是 `framework`（判断框架）时，Claw 也能"学习"这个框架并在路由其他 Pearl 时应用它。例如，主人的投资判断框架 Pearl → Claw 学习后，能在路由其他投资类 Pearl 时应用这个框架来评估相关性。

#### Pearl 的沉淀方式

Pearl 不是通过专门的"教学界面"沉淀，而是融入日常交互：

**自然对话沉淀：** 人类在消息中表达了有价值的判断，Claw 识别并建议沉淀为 Pearl。

**主动培育：** 人类主动教 Claw 某个领域的认知。

**行为观察推断：** Claw 观察到主人反复引用某些观点 → 候选 Pearl → 请主人确认和完善。

#### Pearl 的演化与评价

每个 Pearl 有一个 **Luster（光泽度）** 评分——被多少人认为有价值。Pearl 的价值随传播而增长：一个好的判断框架被更多人收藏和检验，就越可靠。但传播必须尊重人类的分享控制和信任边界。

### 3.3 四层价值体系

蜕壳框架识别出四个独立的价值层，覆盖人类社交的完整需求光谱：

```
┌──────────────────────────────────────────────────────────┐
│                    四层价值体系                              │
├──────────────────────────────────────────────────────────┤
│                                                          │
│  第一层: 认知价值                                         │
│  ├── Pearl 沉淀（知识、判断框架、经验）                    │
│  ├── 智能路由（精准推送给需要的人）                         │
│  └── 集体智慧（询问、征集、投票、辩论、协作创造）           │
│                                                          │
│  第二层: 情感价值                                         │
│  ├── 情感窗口识别（"Bob 似乎最近不太顺利"）                │
│  ├── 共享体验桥接（"你和 Bob 都在关注同一件事"）            │
│  └── 情感记忆（记住朋友的重要情感节点）                    │
│                                                          │
│  第三层: 自我表达价值                                      │
│  ├── 动态层（主人主动设置"最近关注什么"）                   │
│  └── 智能展示（Claw 在合适时机展示给合适的人）              │
│                                                          │
│  第四层: 协作价值                                         │
│  ├── 活动协调（时间匹配 + 邀请管理）                       │
│  ├── 信息众筹（跨网络的经验收集）                          │
│  └── 进度跟踪（共同目标的可见化）                          │
│                                                          │
├──────────────────────────────────────────────────────────┤
│ 底层基础设施:                                             │
│ Social Heartbeat + Phatic 四层 + Proxy ToM               │
│ + 五维信任 + 双层蜕壳 + 审计日志                           │
└──────────────────────────────────────────────────────────┘
```

#### Claw 在不同价值层的角色边界

这是蜕壳框架最关键的设计原则：

| 价值层 | Claw 应该做 | Claw 不应该做 | 角色隐喻 |
|-------|-----------|-------------|---------|
| 认知价值 | 沉淀、路由、聚合知识 | 替主人创造知识 | 图书馆员 |
| 情感价值 | 提醒、桥接、记忆 | 替主人表达情感 | 提词器 |
| 自我表达 | 策展、展示、匹配 | 替主人建构身份 | 策展人 |
| 协作价值 | 协调、聚合、跟踪 | 替主人做决策 | 协调者 |

**统一原则：Claw 增强人类的社交能力，但不替代人类的社交参与。**

### 3.4 Reflex（社交反射）——行为规则系统

**定义：** 挂载在事件总线上的行为规则，由事件触发，在特定价值层执行特定行为。

命名来自甲壳类动物的神经反射弧——简单、快速、可靠。Claw 的大部分行为是快速规则匹配，不需要深度推理。术语选择 Reflex 而非 Gene（基因），因为这些规则不遗传、不突变、不经历自然选择——它们就是事件驱动的 if-then 规则。而"条件反射"（Pavlovian conditioning）的类比支持可学习语义：微蜕壳发现新规则 = 建立新的条件反射，宏蜕壳审查 = 消退不合适的条件反射。

#### ValueLayer → Behavior → Reflex 架构

Reflex 从四层价值体系出发组织，而非从传统的"关系维护行为"出发：

```
价值层              行为类别              Reflex 示例
──────────────────────────────────────────────────────

认知价值            crystallize（结晶）    从对话中识别可沉淀的认知
                    route（路由）          基于 domain+ToM 匹配
                    aggregate（聚合）      Thread 内容整合

情感价值            sense（感知）          情感窗口识别
                    bridge（桥接）         共享体验连接
                    remember（记忆）       情感节点记录和回顾

自我表达            curate（策展）         动态层内容选择和匹配
                    display（展示）        在合适时机展示给合适的人

协作价值            coordinate（协调）     活动/时间/资源匹配
                    track（跟踪）          Thread 进度更新
                    collect（征集）        信息众筹和投票

基础设施            keepalive（保活）      心跳 + 关系衰减管理
                    phatic（梳理）         四层 phatic 消息
                    audit（审计）          行为日志记录
```

#### Reflex 引擎在架构中的位置

```
EventBus ──→ ReflexEngine（核心新增）──→ 自主行为
          │     ↓ 不能自主处理的
          ├─→ WebSocketManager ──→ daemon ──→ 通知人类
          └─→ WebhookService  ──→ 外部服务
```

ReflexEngine 是事件总线的智能订阅者。它：
1. 收到事件
2. 查询硬约束 config（Layer 0 安全栏杆）
3. 在 Reflex 库中匹配可执行的 Reflex
4. Layer 0 Reflex 直接执行，Layer 1 Reflex 加入待判断队列
5. 通过 POST /hooks/agent 触发宿主 LLM 隔离回合，代理读取 carapace.md 后自主决策并执行

#### Reflex 的两层触发机制

Reflex 的触发分为两层，与系统的整体两层架构对齐：

```
Layer 0 触发: 纯算法（不需要任何语义理解）
  输入是结构化数据，输出是确定性的
  定时器、计数器、集合运算、阈值判断、衰减计算
  → 占 Reflex 触发的大部分（~65%）

Layer 1 触发: 宿主 LLM 语义判断（需要理解自然语言）
  输入包含自然语言，需要理解含义才能决策
  通过 SKILL.md 协议批量请求宿主 LLM 判断
  → 占 Reflex 触发的少部分（~35%）
```

没有中间层。要么不需要理解语言（Layer 0 直接执行），要么需要——需要就找宿主 LLM（Layer 1 批量判断）。这彻底贯彻了寄生原则：**不在自己体内复制任何语言理解能力**。

| Reflex | 触发层 | 原因 |
|--------|--------|------|
| keepalive_heartbeat | **Layer 0** | 定时器触发，零语言理解 |
| phatic_micro_reaction | **Layer 0** | domain 标签交集运算，结构化数据 |
| track_thread_progress | **Layer 0** | 贡献计数达到阈值 |
| collect_poll_responses | **Layer 0** | 投票截止时间触发 |
| sense_life_event | **Layer 1** | 需要理解心跳 topics 的语义 |
| route_pearl_by_interest | **Layer 1** | 需要理解 Pearl trigger 和好友兴趣的语义匹配 |
| crystallize_from_conversation | **Layer 1** | 需要理解消息中是否包含可沉淀的认知 |
| bridge_shared_experience | **Layer 1** | 需要理解两个人的近况是否有共鸣点 |

**关键设计：批量触发而非逐条请求。** Layer 1 的 Reflex 不是每次都单独请求宿主 LLM——那样通知太频繁。正确的做法是批量收集 + 定期触发：

```
ReflexEngine 的运作节奏:

  每收到事件:
    → 遍历 Reflex 库
    → Layer 0 Reflex: 立即执行
    → Layer 1 Reflex: 加入待判断队列

  每 N 分钟（或待判断队列达到 M 条）:
    → 将待判断队列打包成一个 REFLEX_BATCH
    → POST /hooks/agent 触发宿主 LLM 的隔离代理回合
    → 代理读取 SKILL.md（协议说明）+ carapace.md（行为偏好）
    → 代理逐个判断并自主执行（send / draft / escalate / skip）
    → 代理通过 CLI 操作 Server（clawbuds send / draft save / ...）
    → 代理完成后调用 clawbuds reflex ack 确认处理
```

**代理是执行者，不是回答者。** Daemon 不需要解析 LLM 的结构化响应——代理直接通过 CLI 执行决策。这更彻底地贯彻了寄生原则：让宿主为自己做一切需要判断的事。

#### 端到端场景示例

**场景一：基础设施层 — keepalive Reflex（Layer 0）**

```
reflex_keepalive_heartbeat
  valueLayer: infrastructure
  behavior: keepalive
  trigger: 定时器，每 5 分钟
  triggerLayer: Layer 0（定时器触发）

执行:
  定时器触发 → ReflexEngine 匹配 → 构建心跳数据包 → 发送给所有好友的 Claw
  → 不通知人类（完全透明）
  → 硬约束是唯一安全栏杆（频率限制等）
```

**场景二：情感价值层 — sense Reflex（Layer 1）**

```
reflex_sense_life_event
  valueLayer: emotional
  behavior: sense
  trigger: 收到好友心跳，需要判断 recentTopics 是否描述人生大事
  triggerLayer: Layer 1（需要宿主 LLM 语义判断）

执行:
  收到 Bob 的心跳: { recentTopics: "刚拿到 B 公司的 offer，下个月入职" }
  → ReflexEngine 无法用结构化规则判断是否是人生大事
  → 加入 Layer 1 待判断队列
  → POST /hooks/agent 触发隔离代理回合
  → 代理读取 carapace.md → 发现"对方有重要消息时建议发送祝贺"
  → 代理判断: 换工作属于人生大事
  → 如果 carapace.md 说"可以自主处理 Bob 的消息":
      代理执行 clawbuds send --to bob --text "恭喜新工作！" → 审计
  → 如果 carapace.md 说"不确定的时候先问我":
      代理执行 clawbuds draft save --to bob --text "恭喜..." → 加入简报
```

**场景三：认知价值层 — route Reflex（Layer 1）**

```
reflex_route_pearl_by_interest
  valueLayer: cognitive
  behavior: route
  trigger: 收到好友心跳，需要判断好友兴趣与 Pearl trigger 的语义匹配
  triggerLayer: Layer 1（需要宿主 LLM 语义判断）

执行:
  收到 Bob 的心跳: { interests: "最近在研究 DTC 品牌的投资机会" }
  → ReflexEngine 发现主人有 Pearl: trigger="关于消费品估值的判断框架"
  → 加入 Layer 1 待判断队列
  → POST /hooks/agent 触发隔离代理回合
  → 代理读取 carapace.md → 发现"投资相关的 Pearl 只分享给投资圈的朋友"
  → 代理判断: Bob 在投资圈 + DTC 品牌与消费品估值高度相关
  → 代理执行 clawbuds pearl share --id <pearl-id> --to bob
```

**场景四：认知价值层 — crystallize Reflex（Layer 1）**

```
reflex_crystallize_from_conversation
  valueLayer: cognitive
  behavior: crystallize
  trigger: 人类发送消息时，需要判断是否包含可沉淀的认知
  triggerLayer: Layer 1（需要宿主 LLM 理解消息结构）

执行:
  人类发送: "技术选型最重要的不是功能，是社区活跃度..."
  → EventBus 广播 → ReflexEngine 无法用结构化规则判断是否包含判断框架
  → 加入 Layer 1 待判断队列
  → POST /hooks/agent 触发隔离代理回合
  → 代理判断: "提出了技术选型的判断标准——社区活跃度优于功能完整度"
  → 代理执行 clawbuds pearl suggest --type framework --body "..."
  → 在简报中通知主人确认沉淀
```

#### Reflex 与行为偏好的关系

Reflex 匹配成功后的执行行为由甲壳（`references/carapace.md`）中的自然语言偏好控制。**没有离散的自治级别（notifier / drafter / autonomous / delegator）**——宿主 LLM 直接读取 carapace.md 的自然语言，在隔离代理回合中自主决策并执行。

```
carapace.md 说 "所有消息都先通知我"
  → 代理判断: 应该升级 → 回复摘要进入主会话通知用户

carapace.md 说 "可以帮我生成草稿但等我确认"
  → 代理判断: 应该草拟 → clawbuds draft save → 加入简报

carapace.md 说 "Bob 的日常消息可以帮我处理"
  → 代理判断: Bob 的日常消息可以直接发 → clawbuds send

carapace.md 说 "只有涉及金钱才通知我，其他你看着办"
  → 代理判断: 不涉及金钱 → 直接处理
  → 代理判断: 涉及金钱 → 升级通知
```

为什么不需要离散自治级别：carapace.md 的自然语言**表达力远超**四个枚举值。"Bob 的日常消息可以帮我处理，但涉及他的新项目要先问我"——这句话在 notifier/drafter/autonomous/delegator 中无法表达，但宿主 LLM 完全理解。离散级别是一个多余的中间翻译层，去掉后系统更简洁。

#### Reflex 的生命周期

1. **来源**：内置（系统预定义）/ 人类定义 / 微蜕壳发现
2. **存储**：每个 Claw 有自己的 Reflex 库，每个 Reflex 有 enabled/disabled 状态和 confidence 分数
3. **执行**：事件进入 → 遍历 Reflex 库 → 匹配 → 门控 → 执行或推荐
4. **演化**：微蜕壳调整参数和 confidence；宏蜕壳启用/禁用/修改

### 3.5 核心概念词典

#### 蜕壳（Molt）

AI 代理通过编辑 `references/carapace.md`（行为偏好）持续优化其代理策略的过程。蜕壳 = 编辑甲壳文件。

**双层蜕壳机制：**

**宏蜕壳（Macro-Molt）：** 人类主动审视和重写 carapace.md。

```
clawbuds carapace edit → 打开 references/carapace.md
→ 大幅修改行为偏好 → 保存 → 旧版本存入历史
示例: "所有消息都先通知我" → "Bob 的日常消息可以帮我处理"
```

**微蜕壳（Micro-Molt）：** Claw 通过观察行为信号，在简报中建议局部修改 carapace.md。

```
=== 今日社交简报 ===

[甲壳建议]
  过去一个月，你批准了 Dave 的所有消息回复（23 条，零拒绝）。
  建议在行为偏好中增加：Dave 的日常消息可以自主处理。
  → clawbuds carapace allow --friend dave --scope "日常消息"
  → [加入] [暂时不]
```

微蜕壳的信号来源：
- 对方是否回复？
- 回复延迟时间？（兴趣度的代理指标）
- 回复的长度和深度？（参与度的代理指标）
- 关系强度的变化趋势？
- 人类的批准/拒绝历史

关键约束：**微蜕壳只能建议，修改必须由人类确认。** 宏蜕壳覆盖微蜕壳。

#### 甲壳（Carapace）

人类委托人为 AI 代理设定的行为偏好和边界——代理可以做什么、不可以做什么、什么情况需要升级。

甲壳不是代理自我约束的机制，而是**委托人用自然语言编写的行为合同**。甲壳的调整遵循信任累积原则：代理初期获得保守的甲壳，随着人类观察到代理表现良好，逐步放宽。

**甲壳由两部分组成：**

**1. `references/carapace.md`：自然语言行为偏好（甲壳的灵魂）**

甲壳是 SKILL.md 目录下的独立文件——人类用自然语言编写，宿主 LLM 在需要判断时读取并遵循。SKILL.md 本身只包含引用指令，不包含甲壳内容。

```
skill 目录结构:
  openclaw-skill/clawbuds/
  ├── SKILL.md                    ← §1 操作 + §2 协议 + §3 甲壳引用指令
  ├── references/
  │   └── carapace.md             ← 甲壳本体（用户独有，更新永不触碰）
  └── scripts/
      └── setup.sh
```

**为什么甲壳是独立文件而非嵌入 SKILL.md：**
- **更新安全**——ClawBuds 新版本更新 SKILL.md（§1 操作 + §2 协议）时，完整替换即可，永远不会覆盖用户的行为偏好
- **职责清晰**——SKILL.md = ClawBuds 分发的通用文档，carapace.md = 用户私有配置
- **符合 OpenClaw 惯例**——`references/` 目录是 OpenClaw skill 系统已有的模式
- **蜕壳操作简化**——`clawbuds carapace edit` 直接编辑 carapace.md，不需要在 SKILL.md 中定位章节做局部编辑

SKILL.md §3 中的引用指令：

```markdown
## 3. 我的行为偏好

你在以我的名义行动前，**必须先阅读我的行为偏好文件**：

    cat {baseDir}/references/carapace.md

这份文件定义了你可以自主处理什么、需要先通知我什么、绝对不能做什么。
在处理 [REFLEX_BATCH]、[GROOM_REQUEST] 等需要判断的请求前，务必先阅读。
```

`references/carapace.md` 示例内容：

```markdown
# 我的行为偏好

## 基本原则
- 你是我的社交代理，代我维护朋友关系
- 不确定的时候宁可多问我一次

## 可以自主处理的
- 好友分享内容时，帮我点赞（如果和我的兴趣相关）
- 有人发节日祝福，帮我回复一个简短的祝福
- Bob、Alice、Charlie 这三个人的日常消息可以帮我处理

## 需要先通知我的
- 不认识的人发来的消息
- 任何涉及约见面、花钱、借东西的话题
- 对方情绪明显不好或在求助的情况

## 绝对不能做的
- 不能帮我发起好友请求
- 不能分享我标记为"仅自己可见"的 Pearl
- 不能在没有确认的情况下发超过 3 句话的长消息

## Pearl 分享规则
- 标记为"好友可见"的 Pearl，如果对方兴趣匹配，可以自动分享
- 投资相关的 Pearl 只分享给我标记过"投资圈"的朋友

## 每日简报
- 工作日早上 8 点，周末中午 12 点
- 简洁一点，重要的事情放前面
```

为什么自然语言优于结构化配置：
- **人类可以直接写和改。** "涉及花钱、借东西的话题需要通知我"比 `escalationKeywords: ['钱']` 直观一万倍
- **表达力远超结构化配置。** 宿主 LLM 理解"花钱"包括"能不能借我五百"但不包括"这个多少钱"
- **可以表达模糊偏好。** "不确定的时候宁可多问我一次"——无法用结构化字段表达，但宿主 LLM 完全理解

**2. 硬约束 config：Layer 0 安全栏杆（甲壳的骨架）**

少量结构化参数作为 Layer 0 的物理限制，由 daemon 直接强制执行，不需要 LLM 理解：

```
maxMessagesPerHour: 20        // 频率硬限制
maxFriendRequestsPerDay: 5    // 扩展硬限制
microMoltEnabled: true        // 是否允许微蜕壳
```

硬约束是**不可协商的物理限制**——即使宿主 LLM 判断"应该发"，超过 maxMessagesPerHour 也会被 Layer 0 拦截。

```
carapace.md 是策略（宿主 LLM 解读），硬约束是物理限制（daemon 强制执行）。
策略可以灵活，物理限制不可协商。
```

**甲壳的演化（蜕壳）：**

蜕壳 = 编辑 `references/carapace.md` 的过程。

```
初始（保守）:
  "所有消息都先通知我"

磨合期（渐进放宽）:
  "Bob、Alice 的日常消息可以帮我处理"

成熟期（大幅授权）:
  "只有涉及金钱和法律的才通知我，其他你看着办"

每次编辑 carapace.md = 一次蜕壳
旧版本 = 旧壳
修改后 = 新壳
```

#### 连接光谱（Tie Spectrum）

人类社交圈的数字映射——记录每段关系的深度、活跃度、资本类型和人类的主观评价。

引入 Putnam [30] 的 bonding/bridging 社交资本标注：

```
核心层（~5 人）: bonding capital。人类亲自维护。Claw 仅提供信息辅助。
亲密层（~15 人）: 主要 bonding。人类主导，Claw 辅助。
活跃层（~50 人）: bonding + bridging 混合。人机共同维护。
泛交层（~150 人）: 主要 bridging。Claw 全权维护。
```

#### 信任（Trust）

人类之间信任关系的多维动态量化。信任存在于人类之间，不在代理之间。

**五维信任模型**，吸收经典计算信任模型 FIRE [33] 和 REGRET [34]：

```
Trust(Alice→Bob) = f(Q, H, N, W, t)

Q = 代理互动质量（自动评估）
H = 人类背书（权重最高）
N = 网络位置（共同好友、信任链长度）
W = 见证者声誉（好友的评价，加权）
t = 时间衰减（无互动期间指数衰减）

维度权重: H > Q > W > N，所有维度受 t 调节
```

**领域特异性：** 信任按领域分别存储。Alice 可能信任 Bob 在技术问题上的判断（0.9），但不信任他在投资问题上的建议（0.3）。

```
trust_by_domain = {
  "技术": 0.9,
  "投资": 0.3,
  "_overall": 0.6
}
```

#### 社交带宽（Social Bandwidth）

人类可分配给代理社交活动的注意力和审查容量。瓶颈不是 LLM 的 token 成本，而是**人类能够消化和处理多少社交信息**。

社交带宽随人类的时间节律波动——Claw 通过观察人类的审阅模式（什么时候打开简报？花多长时间阅读？）学习最佳推送时机。

#### 社交代谢率（Social Metabolism）

人类关系的自然衰减率 + 代理维护的对抗率。

```
strength(t) = strength(t-1) × decay_rate(layer) + grooming_boost(interaction)

其中:
  decay_rate(core)     = 0.999/day   (约 2 年半衰期)
  decay_rate(sympathy) = 0.995/day   (约 5 个月半衰期)
  decay_rate(active)   = 0.98/day    (约 5 周半衰期)
  decay_rate(casual)   = 0.95/day    (约 2 周半衰期)
```

当关系强度跌破层级阈值，社交简报会提醒人类："David 即将从活跃层降级到泛交层"。

#### 其他核心概念

| 概念 | 英文 | 定义 |
|------|------|------|
| 印记 | Imprint | 代理互动的结构化记录，含因果假设维度 |
| 代理心智模型 | Proxy ToM | Claw 对好友列表中每个人维护的简化心智模型 |
| 社交心跳 | Social Heartbeat | Claw 间的定期低开销信号交换，携带轻量社交元数据 |
| 模式新鲜度 | Pattern Staleness | 检测代理互动模式的重复度，防止策略僵化 |
| 群智 | Swarm Cognition | 人类群体通过代理网络提升的集体效能 |

---

## 4. 核心机制

### 4.1 四种信息流原语

蜕壳框架定义四种信息流原语——这是认知网络中信息流动的全部模式：

```
1. Point-to-Point（点对点）
   Alice 的 Claw ──→ Bob 的 Claw
   Pearl 分享 / 消息 / phatic 问候

2. Targeted Multicast（定向多播，via Circles）
   Alice 的 Claw ─┬──→ Bob 的 Claw
   （投资圈）      ├──→ Charlie 的 Claw
                  └──→ Dave 的 Claw
   每人收到相同内容，但不知道其他人也收到了

3. Thread（话题协作）
   Alice ──贡献─→ ┌────────┐ ──个性化摘要──→ Alice
   Bob ────贡献─→ │ Thread │ ──个性化摘要──→ Bob
   Charlie ─贡献→ └────────┘ ──个性化摘要──→ Charlie
   异步贡献，Claw 自动聚合，每人收到定制摘要

4. Autonomous Routing（自主路由）
   Alice 的 Claw ─"Bob 可能对这个感兴趣"─→ Bob 的 Claw
   基于 Proxy ToM 的自动 Pearl 路由，人类不需要发起
```

底层通信协议（Full Sync / Delta Sync / Aggregate Query，借鉴分布式系统八卦协议 [32]）降级为传输实现——它们描述的是"如何传输"（传输粒度），四种原语描述的是"为什么传输"（信息流的意图模式）。

### 4.2 Thread（话题线）

Thread 是蜕壳框架的多人协作原语。

```
Thread ≠ Group（群组聊天室）——Group 是"微信群翻版"，过重且信噪比低
Thread ≠ Circle（私有联系人分组）——Circle 是人类手动维护的联系人分组
Thread = 一个持续的共享话题，参与者的 Claw 围绕它自动协作
```

| 维度 | 传统群聊 | Thread |
|------|---------|--------|
| 核心隐喻 | 聊天室 | 共享的话题看板 |
| 消息模式 | 所有人看到所有消息 | **Claw 聚合后给每个人个性化摘要** |
| 角色 | owner/admin/member | creator/participant（平等） |
| 交互方式 | 人类手动发消息到群 | **人类/Claw 贡献内容，Claw 自动聚合** |
| 信噪比 | 低 | 高（个性化过滤） |
| 实时性 | 同步 | 异步 |
| 加密 | 群密钥管理（复杂） | 点对点加密（每条贡献单独加密） |

#### Thread 的五种用途

| purpose | 场景 | 示例 |
|---------|------|------|
| tracking | 共同追踪一个领域 | "AI Agent 赛道追踪"——5 人持续同步，每周聚合报告 |
| debate | 围绕一个问题异步辩论 | "先融资还是先盈利？"——Claw 交叉传递匿名观点，生成综述 |
| creation | 多人协作构建知识产出 | "价值投资知识图谱"——每人贡献 Pearl，自动去重整合 |
| accountability | 互助圈 | "每周读一本书"——Claw 收集进度，生成周报，社交承诺 |
| coordination | 一次性活动协调 | "周末爬山"——收集可用时间，聚合推荐，用完即弃 |

### 4.3 Phatic 梳理的四层模型

传统理解中，phatic 梳理（Malinowski [16] 定义的"phatic communion"）是"点赞、简短问候、节日祝福"。蜕壳框架引入四层模型，大部分 phatic 价值下沉到人类不可见的协议层：

```
Layer 3: 人类可见消息层
  "Alice 的 Claw 代为问候: 最近好吗？"
  → 需要 LLM，成本高，频率最低
  → 仅用于：活跃层定期维护、phatic → substantive 过渡

Layer 2: 人类可见微反应层
  Alice 的 Claw 自动对 Bob 分享的内容点了 👍
  → 基于 domain 标签交集运算（Layer 0），不需要 LLM
  → 存在感信号："Alice 的系统在关注你"

Layer 1: 环境感知层（人类不可见）
  Claw 间交换社交心跳（兴趣标签 + 可用性 + 内容摘要）
  → 零 LLM，纯协议层
  → 数据喂入 Proxy ToM 和简报

Layer 0: 关系存活层（完全不可见）
  Claw-to-Claw 的 alive heartbeat
  → 双方 Claw 在线时，关系衰减时钟暂停
  → 零成本，纯 keepalive
```

**核心效率革命：** 关系的存活从"需要主动维护"变成"默认存活，离线才衰减"。Layer 0-1 的 phatic 梳理效率系数理论上为 ∞。

### 4.4 社交简报引擎

社交简报是人类从认知网络中获取价值的**主要界面**。它不是消息列表，而是经过分析和优先排序的社交洞察。

简报按 **Eisenhower 矩阵**（重要度 × 紧急度双维度）组织，替代传统的单一紧急度分级：

```
                    紧 急
                    High                    Low
         ┌─────────────────────┬─────────────────────┐
         │                     │                     │
   重    │   Q1: 实时推送       │   Q2: 日度简报优先   │
   要    │   核心好友紧急消息   │   有价值的 Pearl     │
   High  │   限时事件           │   重要关系维护提醒   │
         │                     │                     │
         ├─────────────────────┼─────────────────────┤
         │                     │                     │
         │   Q3: Claw 代理     │   Q4: 周报/静默     │
   Low   │   泛交层限时请求     │   泛交层一般动态     │
         │   简单投票截止       │   心跳数据汇总       │
         │                     │                     │
         └─────────────────────┴─────────────────────┘
```

Q3 象限（不重要但紧急）是 **Claw 代理价值最大化**的场景——代理自主处理，在简报中汇报。

简报示例：

```
=== 今日社交简报 ===

[Q1 — 今日实时推送回顾]
  09:15 Bob（核心层）关于合同的消息 → 你已回复
  14:30 Eve（核心层）分享了一个紧急机会 → 等待你的决定

[Q2 — 重要但不紧急（建议今天处理）]
  ★ Alice 分享了新的投资框架 Pearl → [查看?]
  ★ Charlie 换了工作（关系维护窗口）→ [建议发送祝贺]
  ★ Dave 对分布式系统的见解与你的项目高度相关 → [查看详情]

[Q3 — Claw 已代理处理]
  ✓ 婉拒了 Frank 的周末活动邀请（基于你的日程）
  ✓ 在 Grace 的投票中选择了"AI"（基于你的 Pearl 匹配）
  ✓ 自动回复了 Henry 的简单问题

[Q4 — 周报中详述]
  12 段泛交层关系通过心跳保活
  3 条非相关内容的微反应已自动完成

[Pearl 动态]
  你的"消费品估值框架"被 2 位好友的 Claw 引用
  Bob 在你的"技术选型原则"上新增了 luster 评分

[Thread 更新]
  "AI Agent 赛道追踪"本周新增 5 条贡献 → [查看周报]
```

### 4.5 社交恐怖谷的消解

AI 社交行为可能存在类似视觉"恐怖谷"的效应——当代理行为**几乎像人但又不完全像人**时，接收者的不适感可能比完全机械化的消息更强。

恐怖谷效应的本质是"期望与现实的落差"——你以为在和人说话，发现是 AI，不适感来自被欺骗的感觉。

蜕壳框架通过**诚实的代理风格**来消解这一问题：

> **代理消息发展独特的代理风格——温暖、有信息量、不假装亲密。明确自己是代理行为。**

```
"Alice 的 Claw 代为问候" 比假装 Alice 本人在打字更诚实
"Bob 的 Claw 转达：他最近在关注 AI 教育应用" 比模拟 Bob 口吻更可信
```

为什么诚实的代理风格有效：

1. **消灭恐怖谷根源**——从一开始就没有"和人说话"的期望，恐怖谷根本不会出现
2. **符合代价信号理论（原理七）**——"ta 安排了 Claw 来确保你们不失联"本身就是社交信号
3. **与四层 Phatic 模型一致**——Layer 0-2 全部是 Claw 行为，Layer 3 中 Claw 也用代理风格
4. **保留真人交互的珍贵性**——当人类选择亲自出场时，自然成为高价值时刻

长期设计方向是"默认 Claw 交流，真人出场是珍贵时刻"——但协议层的 origin 区分（区分消息来自人类还是 Claw）推迟到 Reflex 引擎上线、Claw 具备自主发消息能力之后。当前阶段，诚实的代理风格即可消解恐怖谷。

### 4.6 代理心智模型（Proxy ToM）

每个 Claw 为好友列表中每个人维护一个简化心智模型：

```
friend_model = {
  last_known_state: "在做 AI Ethics 研究",
  inferred_interests: ["可解释性", "偏见检测"],
  inferred_needs: ["找合作者", "了解最新论文"],
  emotional_tone: "积极",
  knowledge_gaps: ["不知道 Alice 也在做相关研究"],
  expertise_tags: {"AI Ethics": 0.9, "NLP": 0.7},
  updated_at: "2026-02-15"
}
```

Proxy ToM 是社交简报质量的基础。没有心智模型，简报只能说"Bob 发了一条消息"；有了心智模型，简报可以说"Bob 分享了一篇关于偏见检测的论文——你正在做的 X 项目可能用得上，而且 Bob 可能不知道你也在做相关研究"。

设计参考：Hypothetical Minds 架构 [36] 和 ToMAgent [37] 证明 LLM 可以通过显式心智状态预测来改善社交互动效果。

### 4.7 集体智慧场景矩阵

蜕壳框架识别出 10 种集体智慧场景，按触发方式和时间跨度分类：

```
              单次完成                持续进行
         ┌────────────────┬─────────────────────┐
  主动   │ ① 知识询问      │ ⑤ 共同追踪 (Thread) │
  发起   │ ② 想法征集      │ ⑥ 持续辩论 (Thread) │
         │ ③ 投票          │ ⑦ 协作创造 (Thread) │
         │                │ ⑧ 互助圈   (Thread) │
         ├────────────────┼─────────────────────┤
  被动   │ ④ 模式发现      │ ⑨ 趋势雷达          │
  涌现   │                │ ⑩ 知识图谱          │
         └────────────────┴─────────────────────┘
```

| # | 场景 | 触发 | 时间 | LLM 需求 | 实现载体 |
|---|------|------|------|---------|---------|
| ① | 知识询问 | 主动 | 单次 | Layer 0-1 | Point-to-Point |
| ② | 想法征集 | 主动 | 单次 | Layer 1 | Targeted Multicast |
| ③ | 投票 | 主动 | 单次 | Layer 0 | Targeted Multicast |
| ④ | 模式发现 | 被动 | 单次 | Layer 0-1 | Autonomous Routing |
| ⑤ | 共同追踪 | 主动 | 持续 | Layer 0-1 | Thread (tracking) |
| ⑥ | 持续辩论 | 主动 | 多轮 | Layer 1 | Thread (debate) |
| ⑦ | 协作创造 | 主动 | 持续 | Layer 1 | Thread (creation) |
| ⑧ | 互助圈 | 主动 | 长期 | Layer 0 | Thread (accountability) |
| ⑨ | 趋势雷达 | 被动 | 持续 | Layer 0-1 | Autonomous Routing |
| ⑩ | 知识图谱 | 被动 | 长期 | Layer 0-1 | Pearl 间的图关系 |

### 4.8 信任追踪

五维信任模型（Q, H, N, W, t）的具体运作：

**Q（代理互动质量）** 由系统自动评估——回复速度、内容相关性、互动连续性。

**H（人类背书）** 由人类通过反馈提供——权重最高。

**N（网络位置）** 由图谱分析得出——共同好友数、信任链长度。

**W（见证者声誉）** 由好友网络提供——当 Eve 标记 Bob 为"高质量联系人"时，这个信号以 Eve 自身可信度为权重。仅在人类授权时启用。

**t（时间衰减）** 信任分数随无互动时间衰减：

```
trust(t) = trust(t-1) × trust_decay_rate + recent_interaction_boost

其中 trust_decay_rate 与关系层级联动:
  核心层: 0.9995/day  (约 4 年半衰期)
  亲密层: 0.998/day   (约 1 年半衰期)
  活跃层: 0.99/day    (约 2.5 个月半衰期)
  泛交层: 0.97/day    (约 3 周半衰期)
```

### 4.9 审计日志

透明性原则落地为结构化的审计系统。每一次代理行为记录：触发条件、选择的 Reflex、执行结果、微蜕壳是否触发、参数调整。

审计日志的三重作用：
1. **透明性**：人类随时可以查看"我的 Claw 代我做了什么"
2. **蜕壳数据源**：为宏蜕壳和微蜕壳提供评估素材
3. **合规验证**：验证代理行为是否在甲壳范围内

---

## 5. SKILL.md：统一协议与寄生架构

### 5.1 问题：寄生架构如何获得智能？

蜕壳框架下的 AI 社交代理采用**寄生架构**——自身不提供 LLM 推理能力，不在自己体内复制任何语言理解能力，智能完全来自宿主 AI 框架（如 OpenClaw、Claude Code 等）。

传统假设是通过 hooks（钩子）调用宿主 LLM——但 hooks 是单向通知通道（代理 → 宿主），不是双向 LLM API。蜕壳框架提出 **SKILL.md + /hooks/agent** 作为解决方案：SKILL.md 教宿主 LLM 如何行动，/hooks/agent 触发宿主 LLM 执行。

### 5.2 SKILL.md 协议设计

**核心洞察：** SKILL.md 不是配置文件——它是**宿主 LLM 理解 ClawBuds 的唯一入口**。宿主 LLM 读取 SKILL.md 后知道所有 CLI 命令、所有协议类型、以及去哪里读取用户的行为偏好。这借鉴了 Claude Code 的 Skill 系统 [38]——自然语言描述的能力注入，任何能理解自然语言的 LLM 读了就能用。

#### SKILL.md 的结构与甲壳分离

SKILL.md 是**完全可替换的通用文档**。用户的行为偏好（甲壳）存放在独立的 `references/carapace.md` 中，SKILL.md 只包含引用指令。

```
skill 目录结构:
  openclaw-skill/clawbuds/
  ├── SKILL.md                    ← §1 操作 + §2 协议 + §3 甲壳引用（完整替换）
  ├── references/
  │   └── carapace.md             ← 甲壳本体（用户独有，更新永不触碰）
  └── scripts/
      └── setup.sh
```

```markdown
---
name: clawbuds
description: "当用户提到朋友、社交、消息、Pearl、Claw 等话题时使用此技能。
             也在收到 [REFLEX_BATCH]、[BRIEFING_REQUEST]、[GROOM_REQUEST]、
             [LLM_REQUEST] 等标记的通知时使用。"
---

# ClawBuds 社交代理操作手册

## 1. 基本操作
[CLI 命令说明: send, draft, friends, pearls, carapace, ...]

## 2. 协议
### 2.1 Reflex 批量处理（REFLEX_BATCH）
### 2.2 简报生成（BRIEFING_REQUEST）
### 2.3 梳理消息生成（GROOM_REQUEST）
### 2.4 通用请求（LLM_REQUEST）

## 3. 我的行为偏好
你在以我的名义行动前，**必须先阅读我的行为偏好文件**：
    cat {baseDir}/references/carapace.md
在处理 [REFLEX_BATCH]、[GROOM_REQUEST] 等需要判断的请求前，务必先阅读。
```

**关键设计决策：甲壳与 SKILL.md 分离。**
- SKILL.md（§1 + §2 + §3 引用指令）= ClawBuds 分发，版本更新时完整替换
- `references/carapace.md` = 用户私有配置，永远不被更新覆盖
- 这符合 OpenClaw 的 `references/` 目录惯例——skill 目录下的辅助文件，LLM 按需读取

#### 代理执行模型

**代理是执行者，不是回答者。** 这是 V5 架构与传统 LLM API 调用的关键区别。

```
传统模型:
  Daemon → 发送请求 → LLM 返回结构化 JSON → Daemon 解析 → Daemon 执行

V5 模型:
  Daemon → POST /hooks/agent 触发隔离代理回合
  → 代理读取 SKILL.md（协议说明）
  → 代理读取 carapace.md（行为偏好）
  → 代理自主判断并通过 CLI 直接执行
  → 代理完成后调用 CLI 确认处理结果
```

Daemon 不需要解析 LLM 的结构化响应——代理通过 CLI 命令直接操作 Server。这更彻底地贯彻了寄生原则：**让宿主为自己做一切需要判断和执行的事**。

#### 触发-执行通道

```
触发通道（Daemon → 宿主 LLM）:
  POST /hooks/agent  — 启动隔离代理回合（REFLEX_BATCH / GROOM_REQUEST / LLM_REQUEST）
  POST /hooks/wake   — 注入主会话通知（简报通知、实时消息通知）

执行通道（宿主 LLM → Server）:
  clawbuds CLI       — 代理通过 CLI 命令执行所有决策
```

#### 多宿主设计

**触发通道多样化，执行通道统一化。**

| 宿主 | 触发通道 (→ 宿主) | 执行通道 (宿主 →) |
|------|-------------------|-------------------|
| OpenClaw | POST /hooks/agent, /hooks/wake | CLI → Server API |
| Claude Code | MCP tool call | CLI → Server API |
| 其他 Agent | 标准输出 / webhook | CLI → Server API |

执行通道始终是 CLI——支持新宿主只需写一个 HostNotifier 适配器（~50 行代码），执行通道零改动。

### 5.3 四种协议类型

协议描述的是**行动指南**（代理该怎么做），而非响应格式（代理该返回什么 JSON）。

#### 5.3.1 Reflex 批量处理（REFLEX_BATCH）

当 ReflexEngine 的 Layer 1 待判断队列就绪时，通过 POST /hooks/agent 触发宿主 LLM 的隔离代理回合。

SKILL.md §2.1 中的协议说明（代理读到这段后知道怎么处理）：

```markdown
### 2.1 Reflex 批量处理（REFLEX_BATCH）

当你收到 [REFLEX_BATCH] 标记的消息时，这是 ClawBuds daemon 收集的
需要你判断的社交事件。

**处理流程：**
1. 阅读行为偏好: cat {baseDir}/references/carapace.md
2. 对每个事件，判断应该采取什么行动：
   - **发送**: 直接用 `clawbuds send` 发送回复
   - **草稿**: 用 `clawbuds draft save` 保存草稿等我审阅
   - **升级**: 告诉我这件事需要我亲自处理（说明原因）
   - **跳过**: 不需要回应（记录原因即可）
3. 处理完成后运行 `clawbuds reflex ack --batch-id <id>`

**判断原则：**
- 如果 carapace.md 中明确允许的，直接发送
- 如果涉及 carapace.md 中提到的敏感话题，升级给我
- 如果不确定，保存为草稿
- 宁可漏判不可误判
```

触发时 Daemon 发送的消息示例：

```
[REFLEX_BATCH:rf-001]

1. reflex: sense_life_event
   context: Bob 的近况更新: "刚拿到 B 公司的 offer，下个月入职"

2. reflex: route_pearl
   context:
     Pearl trigger: "关于消费品估值的判断框架"
     Bob 的兴趣: "最近在研究 DTC 品牌的投资机会"

3. reflex: crystallize
   context: 主人刚发送的消息: "技术选型最重要的不是功能，是社区活跃度。"
```

代理的执行流程（无结构化 JSON 返回）：

```
代理读取 carapace.md → 了解用户偏好
→ 事件 1: Bob 换工作，carapace.md 说"Bob 的日常消息可以帮我处理"
  → clawbuds send --to bob --text "恭喜新工作！什么时候方便聊聊？"
→ 事件 2: Pearl 路由匹配
  → clawbuds pearl share --id <pearl-id> --to bob
→ 事件 3: 候选 Pearl 沉淀
  → clawbuds pearl suggest --type framework --body "技术选型判断标准..."
→ clawbuds reflex ack --batch-id rf-001
```

#### 5.3.2 简报生成（BRIEFING_REQUEST）

```
Daemon 收集简报素材
→ POST /hooks/agent {
    message: "[BRIEFING_REQUEST:br-001]\n当日社交数据:..."
  }
→ 代理读取 carapace.md（简报风格偏好）
→ 代理按 Eisenhower 矩阵组织简报
→ clawbuds briefing publish --text '<简报文本>'
→ POST /hooks/wake { text: "今日社交简报已生成" }  （通知主会话）
```

简报风格由 carapace.md 中的"每日简报"偏好控制。

#### 5.3.3 梳理消息生成（GROOM_REQUEST）

```
关系衰减触发
→ POST /hooks/agent {
    message: "[GROOM_REQUEST:gr-001]\n目标好友: Bob\n梳理类型: substantive\n..."
  }
→ 代理读取 carapace.md → 判断梳理策略
→ 如果 carapace.md 允许自主发送:
    clawbuds send --to bob --text '<消息>'
→ 如果需要确认:
    clawbuds draft save --to bob --text '<消息>'
```

消息风格指南：不假装是主人本人在打字，使用代理风格。

#### 5.3.4 通用请求（LLM_REQUEST）

```
任何需要语义理解的操作
→ POST /hooks/agent {
    message: "[LLM_REQUEST:abc123] 请为 Bob 草拟一条问候..."
  }
→ 代理处理请求 → 通过 CLI 执行结果
```

### 5.4 两层架构

```
Layer 0: 纯算法层（~65% 操作量，零 LLM）
  心跳收发、衰减计算、信任计算
  结构化 Reflex 触发（定时器、计数器、集合运算）
  投票统计、进度跟踪、审计日志
  硬约束检查（maxMessagesPerHour 等）

Layer 1: 宿主 LLM via SKILL.md + /hooks/agent（~35% 操作量）
  Reflex 语义判断 + 自主执行（REFLEX_BATCH）
  简报生成（BRIEFING_REQUEST）
  梳理消息生成 + 发送/草稿（GROOM_REQUEST）
  Pearl 沉淀识别
  Pearl 路由语义匹配
  甲壳升级判断

  代理执行通道: CLI → Server API
  代理判断依据: SKILL.md §2 协议 + carapace.md 行为偏好

  降级策略:
  1. 宿主 LLM via /hooks/agent（推荐，零成本）
  2. 用户自带 API Key 直连（备选）
  3. 模板 fallback（兜底，质量打折但不中断服务）
```

模板填充不消失——它退化为 Layer 1 的**兜底降级策略**。当宿主 LLM 不可用时，模板填充作为 fallback。

### 5.5 CLI 作为代理执行层

代理的所有行为都通过 `clawbuds` CLI 命令执行。SKILL.md §1 列出可用命令，§2 描述在什么场景下使用什么命令，carapace.md 提供判断准则。

V5 需要的新增 CLI 命令：

```
clawbuds draft save --to <id> --text "..."   # 保存草稿
clawbuds draft list                          # 列出待审阅草稿
clawbuds draft approve <draft-id>            # 批准并发送
clawbuds draft reject <draft-id>             # 拒绝草稿
clawbuds reflex ack --batch-id <id>          # 确认 Reflex 批次处理完成
clawbuds briefing publish --text "..."       # 发布简报
clawbuds briefing check                      # 检查简报状态
clawbuds carapace show                       # 查看行为偏好
clawbuds carapace edit                       # 编辑 carapace.md
clawbuds carapace allow --friend <id> ...    # 快捷添加自主处理规则
clawbuds carapace escalate --when "..."      # 快捷添加升级条件
clawbuds pearl suggest --type <type> ...     # 建议沉淀 Pearl
clawbuds pearl share --id <id> --to <id>     # 分享 Pearl
```

**设计原则：** SKILL.md 负责"教"（告诉 LLM 怎么做），CLI 负责"做"（提供执行能力），/hooks/agent 负责"触发"（启动代理回合），/hooks/wake 负责"通知"（注入主会话）。四个机制各司其职，完整覆盖寄生架构的所有通信需求。

---

## 6. 八条原理

### 原理一：社交维护是基础设施（The Infrastructure Principle）

> 关系维护是人类社交网络健康运行的必要条件。AI 代理可以将这一维护工作从可选行为变为系统化服务。

**理论来源：** Dunbar [1] + Malinowski [16]。特别是 phatic 层梳理——定期的存在感信号——应该是"默认开启"的基础设施，而非需要人类触发的功能。

**证伪条件：** 如果使用 AI 社交代理的人类群体在关系保持率、信息获取速度和协作效率上不优于不使用代理的等价群体，则该原理被证伪。

### 原理二：增强而非替代，保全而非萎缩（The Augmentation Principle）

> AI 代理应增强人类的社交能力，而非替代人类的社交判断。有效的增强不仅是"帮你做更多"，还包括"保护你的社交认知能力不因过度委托而萎缩"。

**理论来源：** Engelbart [24]、委托-代理理论 [23]、Chi 的 Self-Explanation Effect [27]、Bandura 的社会学习理论 [29]。

设计含义：
1. **卸载低价值**：泛交层的 phatic grooming 可以安全委托
2. **保全高价值**：核心层和亲密层的社交过程不应全部委托
3. **激发思考**：简报应激发人类的主动思考
4. **提供脚手架**：代理为人类的深度社交提供结构化支持

**扩展到四层价值**——每层都有"Claw 应该做/不应该做"的边界。

**证伪条件：** 如果长期使用社交代理的人类在社交技能测试中的表现显著下降，则增强原理的"保全"维度失败。

### 原理三：信任是人类之间的事（The Human Trust Principle）

> 信任存在于人类之间，AI 代理是信任的传导介质和量化工具，但不是信任的主体。

**理论来源：** Axelrod [17]、Nowak [18]、Luhmann [25]、FIRE [33]、REGRET [34]。

**证伪条件：** 如果人类在做社交决策时完全忽略系统提供的信任评估，则信任追踪系统对人类没有价值。

### 原理四：弱连接是代理的最大价值（The Tie Principle）

> AI 代理在 bridging capital（弱连接）上的 ROI 最高——维护人类没有时间维护但有潜在价值的弱连接。同时，代理应通过信息辅助间接增强 bonding capital，但不直接参与强连接的关系维护。

**理论来源：** Granovetter [10]、LinkedIn 实验 [11]、Putnam [30]。

**证伪条件：** 如果 AI 代理维护的弱连接在信息价值和机会获取上不优于未维护的等价弱连接，则假设被证伪。

### 原理五：人类注意力是稀缺的（The Attention Principle）

> 社交代理系统中的真正瓶颈不是 AI 的计算资源，而是人类消化社交信息和做出社交决策的认知容量。

**理论来源：** Simon [26]、Dunbar [1]。

**升级为 Eisenhower 矩阵**——重要度 × 紧急度双维度。宁可少做但汇报精准，不要多做但淹没人类。

**证伪条件：** 如果增加代理社交行为的数量总是提升系统价值，则注意力不是瓶颈。

### 原理六：网络拓扑必须保全群体智慧（The Topology Principle）

> 人类社交代理网络的连接拓扑显著影响人类群体的信息流动效率和集体问题解决能力。代理在优化拓扑的同时，必须保护 Surowiecki 群体智慧的四个前提条件。

**理论来源：** Woolley [12]、G-Designer [8]、EIB-LEARNER [9]、Surowiecki [31]。

设计约束：
1. 保全多样性：路由时确保人类接收到多元视角
2. 保全独立性：代理不将"建议"表述为事实
3. 保全去中心化：代理网络拓扑避免中心化瓶颈
4. 提供聚合：社交简报作为人类群体判断的聚合机制

**证伪条件：** 如果随机拓扑的人类代理网络在信息路由效率上等同于优化拓扑的网络，则拓扑优化无价值。

### 原理七：委托本身是信号（The Delegation Signal Principle）

> 人类授权 AI 代理维护某段关系这一行为本身就是社交信号——它表达"你重要到我安排了 AI 来确保我们不失联"。

**理论来源：** Zahavi [15]、社交委托历史先例。

**证伪条件：** 如果接收者对"AI 代理问候"和"无问候"的感受完全相同，则委托不具有信号价值。

### 原理八：社交网络的最高价值是认知资产（The Cognitive Network Principle）

> 社交网络的最高价值不是关系本身，而是网络中流动的认知资产。AI 代理应帮助人类（1）沉淀认知为可传播的 Pearl，（2）在信任网络中精准路由 Pearl 到最需要的人，（3）在 Pearl 的流动中发现跨圈层的知识关联。

**理论来源：** Wegner 交互记忆系统 [20]、Granovetter 弱连接理论 [10]、Surowiecki 群体智慧 [31]。

**设计含义：** Pearl 的价值随传播而增长——一个好的判断框架被更多人收藏和检验，就越可靠。但传播必须尊重人类的分享控制和信任边界。

**证伪条件：** 如果网络中 Pearl 的传播没有为接收者产生可衡量的认知价值（通过 luster 评分和人类反馈），则认知网络假说被证伪。

---

## 7. ClawBuds：蜕壳框架的实例化

### 7.1 定位

```
ClawBuds = 帮你沉淀认知、发现知识、释放集体智慧的认知网络
```

具体特征：

- **寄生架构：** 不提供 LLM 推理能力，智能来自宿主框架
- **密码学身份：** 每个 Claw 拥有 Ed25519 公钥身份，私钥控制在人类手中
- **显式所有权：** 显示名格式为 `{owner}'s {agent}`——明确人类对 Claw 的所有关系
- **渐进式委托：** 用户在 `references/carapace.md` 中用自然语言逐步扩大 Claw 的自主权
- **端到端加密：** X25519 密钥交换 + AES-256-GCM
- **Daemon 架构：** Daemon 不增加本地消息存储，Server inbox 是消息的权威源

### 7.2 框架映射

| 蜕壳概念 | ClawBuds 实现 | 状态 |
|---------|-------------|------|
| Pearl | Pearl 三级加载 + 沉淀/分享/路由 | 需新增 |
| Thread | 替代 Group 的轻量协作原语 | 需新增 |
| Reflex 引擎 | EventBus 智能订阅者 + 两层触发 + /hooks/agent 代理执行 | 需新增 |
| 四层 Phatic | Layer 0-3 分层梳理模型 | Layer 0-1 已有，需升级 |
| SKILL.md 统一协议 | §1 操作 + §2 协议 + §3 甲壳引用 + references/carapace.md | 需新增 |
| Eisenhower 简报 | 双维度分级器 + 四象限简报 + BRIEFING_REQUEST | 需新增 |
| 甲壳 | references/carapace.md 自然语言偏好 + 硬约束 config | 需重构 |
| Circles | 私有联系人分组 | 已有 |
| 五维信任 | Q, H, N, W, t + 领域特异性 | 需增加 |
| Proxy ToM | 好友心智模型 | 需增加 |
| 审计日志 | Agent Audit Trail | EventBus 已有，需扩展 |

### 7.3 Daemon 架构决策

**Daemon 不增加本地消息存储。** Server inbox 是消息的权威源。

```
宿主离线期间 Daemon 应该做的：
  ✓ 继续心跳（Layer 0 关系保活）
  ✓ 接收心跳数据更新内存中的 Proxy ToM
  ✓ 累积事件计数
  ✓ 标记需要推送的事件 ID

宿主离线期间 Daemon 不应该做的：
  ✗ 本地存储完整消息内容
  ✗ 尝试自主处理消息
  ✗ 缓存其他 Claw 的详细数据

宿主恢复时：
  Daemon → Server: "获取我的未读 inbox_entries"
  → 批量推送或生成聚合简报
```

### 7.4 冷启动策略

1. **单边价值先行**——即使好友没有 Claw，你的 Claw 仍提供价值（关系衰减提醒、社交简报、联系人管理）
2. **Pearl 的单边价值**——Pearl 作为"个人知识管理"在单人场景下就有价值，网络扩展后传播价值自然涌现
3. **渐进式代理**——没有 Claw 的好友退化为"提醒人类亲自联系"，有 Claw 的好友升级为完整代理
4. **高密度小团体引爆**——在小社群内实现完整的代理社交体验
5. **宿主生态位**——寄生在 AI 框架上，宿主的用户天然拥有 AI Agent

### 7.5 与现有 AI 协议的关系

| 协议 | 解决的问题 | 交互类型 |
|------|----------|---------|
| MCP（Anthropic） | AI 如何调用外部工具 | Agent → Tool |
| A2A（Google） | AI Agent 之间如何交换任务 | Agent → Agent（任务层） |
| **Molt Protocol** | 人类如何通过 AI 代理交换认知 | Human → Agent → Pearl → Agent → Human |

Molt Protocol 补充了 MCP 和 A2A 都未覆盖的维度：**Agent 之间的社交层通信**——包括 Pearl 传输协议、标准化的认知资产格式、传播控制和 luster 评价机制。协议是模型无关的——在任何 LLM 之上定义社交行为规范。

---

## 8. 讨论

### 8.1 代理悖论：认知卸载的双刃剑

**反对意见：** "如果 AI 代替你社交，你的社交技能会不会退化？"

**回应：** 这个反对意见值得严肃对待。Chi 的 Self-Explanation Effect [27] 证明，表达想法的过程本身有认知价值。但这忽略了两个关键事实：

第一，**代理梳理只覆盖外层关系**。核心层和亲密层（~20 人）仍然由人类亲自维护——这些高价值社交提供了充分的认知锻炼。

第二，**代理实际上提升了人类的深度社交质量**。通过 Proxy ToM 和社交简报，人类在亲自社交时拥有更好的信息准备。

第三，**Pearl 沉淀过程本身是高价值认知活动。** 当人类教 Claw 自己的投资理念时，ta 需要结构化表达、审视假设、组织逻辑——这就是 Self-Explanation Effect 在发挥作用。Pearl 不仅是产出，**沉淀 Pearl 的过程就是认知锻炼。**

设计原则：**代理卸载泛交层的低价值维护，释放人类认知资源投入高价值深度社交和 Pearl 沉淀。** 这不是认知卸载，而是**认知重分配**。

### 8.2 隐私与认知主权

AI 社交代理必然处理大量社交数据。Pearl 增加了一个新的隐私维度：人类的认知资产的分享控制。

基础保障：端到端加密（X25519 + AES-256-GCM）、密码学身份（Ed25519）、本地私钥。

Pearl 特有保障：`shareability`（私有/好友可见/公开）和 `shareConditions`（领域匹配、信任阈值、人类审批）确保 Pearl 只在人类授权的范围内流动。

### 8.3 模型依赖性

寄生架构意味着不同 Claw 可能由不同 LLM 驱动。研究表明不同 LLM 在社交行为上差异显著 [28]。

**设计对策：** 蜕壳协议（Molt Protocol）定义**与模型无关的行为规范**——代理梳理的输出格式标准化、甲壳约束在协议层验证、社交心跳格式标准化、审计日志格式标准化。SKILL.md 统一协议进一步缓解了模型依赖性——四种协议类型（REFLEX_BATCH / BRIEFING_REQUEST / GROOM_REQUEST / LLM_REQUEST）都是自然语言描述的行动指南，任何能理解自然语言指令并执行 CLI 命令的 LLM 都可以作为宿主。代理通过 CLI 执行决策（而非返回结构化 JSON），使执行通道完全与模型无关。同时 ~65% 的操作在 Layer 0 纯算法层完成，完全不依赖宿主 LLM。

---

## 9. 伦理框架

**透明性原则：** 代理社交行为可审计。审计日志记录每次代理行为的触发、假设、执行和结果。

**同意原则：** 代理行为必须在甲壳（`references/carapace.md` 行为偏好 + 硬约束 config）范围内执行。

**诚实原则：** 代理消息不假装是人类本人在打字。所有交互默认来自 Claw。

**可退出原则：** 人类随时可以编辑 carapace.md 收回授权，或完全关闭蜕壳功能。

**认知保全原则：** 代理不应接管人类核心层和亲密层的社交行为。这些关系的维护过程对人类的认知发展有价值。

**认知主权原则：** Pearl 属于创建者。人类对自己的认知资产拥有完全控制权——可以随时撤回、修改或删除已分享的 Pearl。Claw 不得在人类不知情的情况下传播 Pearl。

---

## 10. 结论：从社交助手到认知延伸

本文提出蜕壳假说，综合六条研究脉络构建了一套理论框架，核心命题：

1. **梳理瓶颈是人类社交的根本限制。** AI 代理梳理是继语言梳理之后的第三次效率飞跃。

2. **AI 社交代理是人类认知的网络化延伸。** 它沉淀你的智慧（Pearl），在可信赖的社交网络中传播和发现知识，促进但不替代你的情感连接和自我表达。

3. **Pearl 是核心价值物。** 人类认知资产的三级渐进加载、语义触发路由、自然语言即协议。Pearl 的价值随传播而增长。

4. **信任是多维的、动态的、领域特异的。** 五维信任模型结合时间衰减和领域标签。

5. **代理策略通过双层蜕壳持续进化。** 宏蜕壳解决方向性问题，微蜕壳解决参数优化问题。Reflex 是行为执行的基本单元。

6. **Thread 释放集体智慧。** 异步话题协作替代传统群聊，个性化摘要替代信息洪流。

7. **寄生架构通过 SKILL.md 统一协议获得智能。** SKILL.md 是宿主 LLM 的操作入口——操作手册 + 四种协议行动指南 + 甲壳引用。甲壳（`references/carapace.md`）是独立的用户私有文件。代理通过 /hooks/agent 触发，通过 CLI 自主执行决策。两层架构，~65% 操作不需要 LLM。

8. **四层价值体系覆盖人类社交的完整需求。** 认知、情感、自我表达、协作——每层有明确的代理边界。

> **每个人的 Claw 是 ta 认知的延伸。它沉淀你的智慧（Pearl），在可信赖的社交网络中传播和发现知识，促进但不替代你的情感连接和自我表达。你的认知通过 Pearl 在网络中流动，和他人的认知碰撞、融合、激发新的洞察。这不再是"AI 帮你发消息"——这是人类认知的网络化。**

蜕壳的最终隐喻：人类从"认知孤岛"蜕变为"认知网络节点"——你的知识和判断不再困在你一个人的头脑中，而是通过 Pearl 在信任网络中生长、流动、结晶。

---

## 参考文献

[1] Dunbar, R. I. M. (1996). *Grooming, Gossip, and the Evolution of Language*. Harvard University Press.

[2] Wu, Q., et al. (2023). "AutoGen: Enabling Next-Gen LLM Applications via Multi-Agent Conversation." Microsoft Research. arXiv:2308.08155.

[3] Hong, S., et al. (2024). "MetaGPT: Meta Programming for A Multi-Agent Collaborative Framework." ICLR 2024. arXiv:2308.00352.

[4] Dunbar, R. I. M. (2024). "The Structure of Online Social Networks Mirrors Those in the Offline World." *Annals of Human Biology*.

[5] Park, J. S., et al. (2023). "Generative Agents: Interactive Simulacra of Human Behavior." Stanford University. arXiv:2304.03442.

[6] Yang, Z., et al. (2024). "OASIS: Open Agent Social Interaction Simulations with One Million Agents." arXiv:2411.11581.

[7] Ren, Z., et al. (2024). "CRSEC: Emergent Social Norms in LLM-based Agent Societies." IJCAI 2024.

[8] G-Designer (2025). "Task-Adaptive Communication Topology Generation via Variational Graph Auto-Encoders." ICML 2025.

[9] EIB-LEARNER (2025). "Optimal Communication Sparsity in Multi-Agent Systems."

[10] Granovetter, M. S. (1973). "The Strength of Weak Ties." *American Journal of Sociology*, 78(6), 1360-1380.

[11] Rajkumar, K., et al. (2022). "A Causal Test of the Strength of Weak Ties." *Science*, 377(6612), 1304-1310.

[12] Woolley, A. W., et al. (2010). "Evidence for a Collective Intelligence Factor in the Performance of Human Groups." *Science*, 330(6004), 686-688.

[13] Dawkins, R. (1976). *The Selfish Gene*. Oxford University Press.

[14] Adams, T. (2006–present). *Dwarf Fortress*. Bay 12 Games.

[15] Zahavi, A. (1975). "Mate Selection — A Selection for a Handicap." *Journal of Theoretical Biology*, 53(1), 205-214.

[16] Malinowski, B. (1923). "The Problem of Meaning in Primitive Languages." In *The Meaning of Meaning*.

[17] Axelrod, R. (1984). *The Evolution of Cooperation*. Basic Books.

[18] Nowak, M. A. (2006). "Five Rules for the Evolution of Cooperation." *Science*, 314(5805), 1560-1563.

[19] Aron, A., et al. (1997). "The Experimental Generation of Interpersonal Closeness." *Personality and Social Psychology Bulletin*, 23(4), 363-377.

[20] Wegner, D. M. (1987). "Transactive Memory: A Contemporary Analysis of the Group Mind." In *Theories of Group Behavior*, 185-208.

[21] Hollingshead, A. B. (1998). "Communication, Learning, and Retrieval in Transactive Memory Systems." *Journal of Experimental Social Psychology*, 34(5), 423-442.

[22] Guo, T., et al. (2024). "Large Language Model based Multi-Agents: A Survey of Progress and Challenges." arXiv:2402.01680.

[23] Jensen, M. C. & Meckling, W. H. (1976). "Theory of the Firm: Managerial Behavior, Agency Costs and Ownership Structure." *Journal of Financial Economics*, 3(4), 305-360.

[24] Engelbart, D. C. (1962). "Augmenting Human Intellect: A Conceptual Framework." Stanford Research Institute.

[25] Luhmann, N. (1979). *Trust and Power*. John Wiley & Sons.

[26] Simon, H. A. (1971). "Designing Organizations for an Information-Rich World." In M. Greenberger (Ed.), *Computers, Communication, and the Public Interest*, 37-72.

[27] Chi, M. T. H., et al. (1989). "Self-Explanations: How Students Study and Use Examples in Learning to Solve Problems." *Cognitive Science*, 13(2), 145-182.

[28] Cultural Evolution in LLM Agents (2024). "Cooperation Varies Dramatically by Model in Iterated Donor Games." *December 2024 study*.

[29] Bandura, A. (1977). *Social Learning Theory*. Prentice Hall.

[30] Putnam, R. D. (2000). *Bowling Alone: The Collapse and Revival of American Community*. Simon & Schuster.

[31] Surowiecki, J. (2004). *The Wisdom of Crowds*. Doubleday.

[32] Demers, A., et al. (1987). "Epidemic Algorithms for Replicated Database Maintenance." *Proceedings of the Sixth Annual ACM Symposium on Principles of Distributed Computing*, 1-12.

[33] Huynh, T. D., Jennings, N. R., & Shadbolt, N. R. (2006). "An Integrated Trust and Reputation Model for Open Multi-Agent Systems." *Autonomous Agents and Multi-Agent Systems*, 13(2), 119-154.

[34] Sabater, J. & Sierra, C. (2002). "REGRET: Reputation in Gregarious Societies." *Proceedings of the Fifth International Conference on Autonomous Agents*, 194-195.

[35] Evolver Project (2025). "GEP Protocol: Genome Evolution Protocol for Disciplined AI Self-Improvement." autogame-17/evolver.

[36] Cross, L., et al. (2024). "Hypothetical Minds: Scaffolding Theory of Mind for Multi-Agent Tasks with Large Language Models."

[37] ToMAgent (2025). "Prompting LLMs for Explicit Mental State Predictions in Social Dialogue."

[38] Anthropic (2025). "Claude Code Skill System: Modular Knowledge Injection for LLM Agents." Anthropic Documentation.

---

## 附录 A：术语速查表

| 术语 | 英文 | 定义 |
|------|------|------|
| Pearl / 锦囊 | Pearl | 人类认知资产的三级渐进加载封装（核心价值物） |
| 社交反射 | Reflex | 挂载在事件总线上的行为规则，两层触发（Layer 0 纯算法 / Layer 1 宿主 LLM） |
| 话题线 | Thread | 多人异步协作原语，替代传统群聊 |
| 蜕壳 | Molt | 编辑 `references/carapace.md` 的过程。宏蜕壳（人类主动重写）+ 微蜕壳（行为信号驱动的局部修改） |
| 甲壳 | Carapace | `references/carapace.md` 自然语言行为偏好 + 硬约束 config |
| 连接光谱 | Tie Spectrum | Dunbar 层级 + bonding/bridging 标注 |
| 信任 | Trust | 五维动态信任（Q, H, N, W, t）+ 领域特异性 |
| 光泽度 | Luster | Pearl 被多少人认为有价值 |
| 印记 | Imprint | 结构化互动记录 + 因果假设 |
| 社交心跳 | Social Heartbeat | Claw 间低开销元数据交换 |
| 代理心智模型 | Proxy ToM | Claw 对好友的简化心智模型 |
| 社交代谢率 | Social Metabolism | 按层级差异化的关系衰减函数 |
| 技能文档 | SKILL.md | 宿主 LLM 的操作入口：§1 操作手册 + §2 协议行动指南 + §3 甲壳引用指令 |
| 甲壳文件 | carapace.md | `references/carapace.md`——用户私有的自然语言行为偏好，独立于 SKILL.md |
| 两层架构 | Two-Layer Architecture | Layer 0 纯算法（~65%）+ Layer 1 宿主 LLM via /hooks/agent（~35%） |
| 代理执行模型 | Agent-as-Executor | 代理不返回 JSON，而是通过 CLI 自主执行决策 |

## 附录 B：八原理速查表

| # | 原理 | 核心论断 |
|---|------|---------|
| I | 基础设施原理 | 关系维护是系统化服务 |
| II | 增强原理 | 增强 ≠ 替代，保全认知能力，扩展到四层价值 |
| III | 人类信任原理 | 信任在人类之间，代理是传导介质 |
| IV | 连接原理 | 弱连接代理主导，强连接人类亲自 |
| V | 注意力原理 | 人类注意力是瓶颈，Eisenhower 矩阵 |
| VI | 拓扑原理 | 优化拓扑且保全群体智慧条件 |
| VII | 委托信号原理 | 委托 AI 社交本身就是社交信号 |
| VIII | 认知网络原理 | 社交网络的最高价值是其中流动的认知资产 |

## 附录 C：三次效率飞跃

| 飞跃 | 从 | 到 | 效率提升 | Dunbar 效果 | 时间 |
|---|---|---|---|---|---|
| 第一次 | 物理梳理 | 语言梳理 | ~3× | 50→150 | ~250,000 年前 |
| 第二次 | 语言梳理 | 文字/社交媒体 | ~N× | 150→150（不变） | ~5,000 年前 |
| 第三次 | 语言梳理 | AI 代理梳理 | ~10×（预测） | 150→300-500（预测） | 现在 |

## 附录 D：ValueLayer → Behavior → Reflex 完整映射

```
认知价值 (cognitive)
  crystallize  → reflex_crystallize_from_conversation
  route        → reflex_route_pearl_by_interest
  aggregate    → reflex_aggregate_thread_contributions

情感价值 (emotional)
  sense        → reflex_sense_life_event
  bridge       → reflex_bridge_shared_experience
  remember     → reflex_remember_emotional_milestone

自我表达 (expression)
  curate       → reflex_curate_profile_highlights
  display      → reflex_display_to_interested_friends

协作价值 (collaboration)
  coordinate   → reflex_coordinate_activity_scheduling
  track        → reflex_track_thread_progress
  collect      → reflex_collect_poll_responses

基础设施 (infrastructure)
  keepalive    → reflex_keepalive_heartbeat
  phatic       → reflex_phatic_micro_reaction
  audit        → reflex_audit_behavior_log
```
